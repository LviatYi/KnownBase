# 6. 集成测试

## 6.1 概述

**集成测试** ，也叫 **组装测试** 或 **联合测试** 。  
集成测试在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。  

> 软件在系统集成时会经常有这样的情况发生：  
>  
> * 每个模块都能单独工作 ，但这些模块集成在一起之后却不能正常工作。  
> * 或是系统集成后虽可以正常运行，但系统的容错性、安全性以及整体性却得不到保障，系统不能
> 长时间运行等等。  

单元测试、集成测试与系统测试的差别

| | 测试依据 | 目的 | 测试依据 | 测试方法|
-|------|----|------|-----|--
单元测试|模块内部程序错误|消除局部模块逻辑和功能上的错误和缺陷|模块逻辑设计/模块外部说明|大量采用白盒测试方法
集成测试|模块间的集成和调用关系|找出与软件设计相关的程序结构，模块调用关系，模块间接口方面的问题|程序结构设计|灰盒测试，采用较多黑盒方法构造测试用例
系统测试|整个系统，包括系统软硬件等|对整个系统进行一系列的整体、有效性测试|系统结构设计/目标说明书/需求说明书等|黑盒测试

**灰盒测试** 是介于白盒测试与黑盒测试之间的一种测试。其多用于集成阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。  

> 单元测试通常是单人执行，而集成测试通常是 **多人执行** 或 **第三方执行** 。集成测试通过模块间的交互作用和不同人的理解和交流，更容易发现实现上、理解上的不一致和差错。  

一般，集成测试划分为四个阶段：  

* 计划阶段
* 设计阶段
* 执行阶段
* 评估阶段

## 6.2 测试方法

### 6.2.1 测试原则

* 集成测试是产品研发中的重要工作，需要为其分配足够的资源和时间。  
* 集成测试需要经过严密的计划，并严格按计划执行。  
* 应采取增量式的分步集成方式，逐步进行软件部件的集成和测试。  
* 应重视测试自动化技术的引入与应用，不断提高集成测试效率。  
* 应该注意测试用例的积累和管理，方便进行回归并进行测试用例补充。  

### 6.2.2 测试重点

* 在把各个模块连接起来时，穿越模块接口的数据是否会丢失。  
* 各个子功能组合起来，能否达到预期要求的父功能。  
* 一个模块的功能是否会对另一个模块的功能产生不利的影响。  
* 全局数据结构是否有问题，会不会被异常修改。  
* 单个模块的误差积累起来，是否会放大，从而达到不可以接受的程度。  

### 6.2.3 测试对象

集成测试关注的是模块之间的接口。接口大致有以下几种类型：

* **通信协议**
  * 两个模块之间通信采用的是标准的或者自定义的协议。  
  * 协议中即包含数据部分，又包含控制部分。  
  * 而大部分实现数据与控制通过一条链路来传递，往往通过不同的消息包进行分离。  
* **调用关系**
  * 模块A调用模块B，实际上是由模块 A 向模块 B 发出了一条控制指令。  
  * 往往体现为参数与返回值。  
* **文件、数据库、队列、第三方中间件等**
  * 主要表现为数据的传递。  
* **共享资源**
  * 表现为对资源的竞争，以及数据的共享。  
* **同步**
  * 一个模块的运行需要另外一个模块的触发，双方往往存在「信号」等通知机制，也可以理解为一种特殊的控制方式。  

## 6.3 设计过程

明确了测试对象以后，就可按照一般的测试方法设计和实施测试了。测试思路如下：

* 找出系统中的各种接口。  
  如需要传递哪些数据？存在哪些控制指令？如数据（协议包）中字段取值，指令参数变化等。  
* 将不同的控制指令等划分等价类。  
  找出每类的代表，得到测试数据，让每类数据流与控制流均通过接口一次，从而实现接口测试的完全性。  
* 综合考虑。
  考虑模块的集成能否准确体现业务上的关联？各个模块是否具备其角色的全部属性和接口？  

应按照思路设计集成测试方案。方案应包括如下内容：  

* **被测特性的分析**
  * 即对整个测试的对象做个简要而精准的分析说明。  
  * 如测试的是一个程序，则应说明该程序的主要功能和特征。  
* **采用的集成策略**
  * 如自顶向下或自底向上的集成策略，并说明采用此种策略的原因和理由。  
* **测试对象的详细描述和设计测试用例**
  * 说明设计的思路。  
  * 这里的对象就是具体的测试内容，如两模块之间的的接口。  
* **测试结果的分析**
  * 测试完成后，根据测试中发现的问题，应对每个测试对象的结果进行分析和说明。并在最后说明整个测试情况，发现的缺陷数量，各种等级缺陷的分布情况，以及缺陷清单。  

一般可以根据不同的集成力度把集成测试划分为三个级别：

* **模块内集成测试**
* **子系统内集成测试**
  先测试子系统内的功能模块，然后将各个功能模块组合起来确认子系统的功能是否达到预期要求。  
* **子系统间集成测试**
  测试的单元是子系统之间的接口。子系统是可单独运行的程序或进程。

对于面向对象的应用系统来说，可分为 **类内** 与 **类间** 集成测试两个层次。  

### 6.3.1 测试策略

#### 非增量方式

非增量方式即 **大爆炸 (Big Bang)** 或 **大棒** 测试，采用 **一步到位** 的方法来构造测试。单元测试结束后，一次性组装并测试整个程序。  
适应于一个维护型或被测试系统较小的项目。  

在非增量式集成测试时，应当确定关键模块，对这些关键模块及早进行测试。  
关键模块具有以下特征：  

* 完成需求规格说明中的关键功能。  
* 在程序的模块结构中位于较高的层次（高层控制模块）。  
* 较复杂、较易发生错误。  
* 有明确定义的性能要求。  
  
#### 增量方式

增量方式逐步把下一个要被组装的软件单元或部件，与已受测的其他部件结合起来测试。  
增量式测试的集成是 **逐步实现** 的。  

增量方式主要包括以下方法：  

* 自顶向下方法 (Top-Down)
* 自底向上方法 (Bottom-Up)
* 「三明治」方法 (Sandwich)

##### 自顶向下方法

自顶向下增量式测试即按照 **结构图** 自上而下进行逐步集成和逐步测试。  

* 模块集成首先集成 **主控模块**（主程序），然后依照 **控制层次结构** 向下进行集成。  
* 从主控模块按 **深度优先方式**（纵向）或者 **广度优先方式**（横向）集成到结构中去。  

方法：  

1. 首先以 **主模块** 为所测模块兼驱动模块，所有直属于主模块的下属模块全部用 **桩模块** （没有实际功能的填充模块）替代，然后对主模块进行测试。
2. 采用深度优先或广度优先的策略，用实际模块替换相应桩模块，再用桩代替它们的直接下属模块，与已测试的模块或子系统集成为新的子系统。
3. 进行回归测试（即重新执行以前做过的全部测试或部分测试），排除集成过程中引起错误的可能。
4. 判断是否所有的模块都已集成到系统中，是则结束测试，否则转到 *2.* 去执行。  

优点：  

* 较早地验证了主要控制和判断点。  
* 按深度优先可以首先实现和验证一个完整的软件功能。  
* 功能较早证实，带来信心。  
* 只需一个驱动，减少驱动器开发的费用。  
* 支持故障隔离。  

缺点：  

* 另外需要进行桩模块的开发。  
* 底层验证被推迟。  
* 底层组件测试不充分。  

适用范围：  

* 产品控制结构比较清晰和稳定。  
* 高层接口变化较小。  
* 底层接口未定义或经常可能被修改。  
* 产品控制组件具有较大的技术风险，需要尽早被验证。  
* 希望尽早能看到产品的系统功能行为。  

##### 自底向上方法

自底向上增量式测试即按照 **依赖关系树** 的结构从具有最小依赖性的底层组件开始逐步集成和逐步测试。  
是 **最常用** 的集成策略。  

* 需要为所测模块或子系统编制相应的驱动模块。  

方法：  

1. 起始于模块依赖关系树的 **底层叶子模块** ，也可以把两个或多个叶子模块合并到一起进行测试。  
2. 使用驱动模块对 *1.* 选定的模块（或模块组）进行测试。  
3. 用实际模块代替驱动模块，与它已测试的直属子模块组装成一个更大的模块进行测试。  
4. 重复上面的行为直到系统最顶层模块被加入到已测系统中。  

优点：  

* 对底层组件行为较早验证。  
* 可以 **并行集成** ，比自顶向下效率高。  
* 能较好锁定软件故障所在位置。  

缺点：  

* 需要开发驱动模块。  
* 对高层的验证被推迟，设计上的错误不能被及时发现。  

适用范围：  

* 适应于底层接口比较稳定。  
* 高层接口变化比较频繁。  
* 底层组件较早被完成。  

##### 三明治方法

三明治集成方法是一种混合测试策略，综合了自顶向下和自底向上两种集成方法的优点。  
测试人员需要确定以哪一层为界。其下使用自底向上，其上使用自顶向下。  

优点：  

* 它将自顶向下和自底向上的集成方法有机地结合起来，一般对软件结构的上层使用自顶向下结合的方法；对下层使用自底向上结合的方法。  
* 运用一定的技巧，能够减少了桩模块和驱动模块的开发。  

缺点：  

* 在被集成之前，中间层不能尽早得到充分的测试。  

适用范围：  

* 适应于底层接口比较稳定。  
* 高层接口变化比较频繁。  
* 底层组件较早被完成。  

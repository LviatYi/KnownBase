# 22. 状态模式

## 22.1 模式动机

某些对象存在多种状态，不同状态能够决定对象的不同行为，且其状态能在某些条件下相互转换。可使用 **状态模式** 进行设计。

状态模式用于解决系统中复杂对象的 **状态转换** 以及 **不同状态下行为** 的封装问题。

状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。

## 22.2 模式定义

> **状态模式** (State Pattern) ，它属于对象行为型模式。
>
> - 允许一个对象在其内部状态改变时改变行为。
> - 对象看起来似乎修改了自身的类。

## 22.3 模式结构

- Context 环境类
  - 又称为上下文类，是拥有多种状态的对象。
  - 由于其状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。
  - 在环境类中维护一个状态类的实例以定义当前状态。
- State 抽象状态类
  - 定义一个接口以封装与环境类的一个特定状态相关的行为。
  - 声明了各种不同状态对应的方法，在其子类中实现这些方法。
  - 由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同。
  - 相同的方法可以写在抽象状态类中。
- ConcreteState 具体状态类
  - 抽象状态类的子类。
  - 每个子类实现一个与环境类某状态相关的行为。
  - 每个具体状态类对应环境的一个具体状态，不同的具体状态类允许有不同行为。

```PlantUML
@startuml Observer_ClassDiagram
hide empty members

class Context{
    - state : State
    + request()
    + setState(State state)
}

class State{
    + handle()
}

class ConcreteStateA{
    + handle()
}

class ConcreteStateB{
    + handle()
}

Context o--> State
State <|-- ConcreteStateA
State <|-- ConcreteStateB
@enduml
```

## 22.4 时序图

## 22.5 代码分析

```JAVA
abstract class State {
    //声明抽象业务方法，不同的具体状态类可以不同的实现
    public abstract void handle();
}
```

```JAVA
class ConcreteState extends State {
    public void handle() {
        //方法具体实现代码
    }
}
```

```JAVA
class Context {
    private State state; //维持一个对抽象状态对象的引用
    private int value; //其他属性值，该属性值的变化可能会导致对象状态发生变化

    //设置状态对象
    public void setState(State state) {
        this.state = state;
    }

    public void request() {
        //其他代码
        state.handle(); //调用状态对象的业务方法
        //其他代码
    }
}
```

## 22.6 模式分析

- 环境类是真正拥有状态的对象。
- 将环境类中与状态有关的部分封装到专门的状态类中。
- 实际使用时，环境类与抽象状态类可能存在单向关联关系之外更为复杂的关系（依赖或关联关系）。

通常存在两种实现状态转换的方式：

- 由环境类负责状态间的转换。
- 由具体状态类负责状态间的转换。

## 22.7 实例

## 22.8 优点

- 封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。
- 将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。
- 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。
- 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。

## 22.9 缺点

- 状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。
- 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。
- 状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。

## 22.10 适用环境

- 对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化。
- 在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。

## 22.11 模式应用

## 22.12 模式扩展

# 4. 语法分析

## 4.1 语法分析简述

### 4.1.1 语法分析器的作用

语法分析器从词法分析器获得一个由词法单元组成的串，并验证这个串可以由源语言的文法生成。

语法分析器能够以易于理解的方式报告语法错误，并且能够从常见的错误中恢复并继续处理程序的其余部分。

从概念上讲，对于良构的程序，语法分析器构造出一棵语法分析树，并把它传递给编译器的其他部分进一步处理。  
但实际上，并不需要显式地构造出这棵语法分析树，因为正如我们将看到的，对源程序的检查和翻译动作可以和语法分析过程交错完成。因此，语法分析器和前端的其他部分可以用一个模块来实现。

处理文法的语法分析器大体上可以分为三种类型：

- 通用的
- 自顶向下的（常用的）
- 自底向上的（常用的）

### 4.1.2 语法错误的处理

一般使用如下两种策略进行错误处理：

- 恐慌模式
- 短语层次恢复

程序可能存在不同层次的错误：

- 词法错误
  > 标识符、关键字或运算符拼写错误。  
  >  没有在字符串文本上正确地加上引号。
- 语法错误
  > 错误的分号位置、括号的多余或缺失。  
  >  一个 `case` 语句的外围没有相应的 `switch` 语句（然而，语法分析器通常允许这种情况出现，当编译器在之后要生成代码时才会发现这个错误）。
- 语义错误
  > 运算符和运算分量之间的类型不匹配。
- 逻辑错误
  > 可以是因程序员的错误推理而引起的任何错误。  
  >  如应该使用比较运算符 `==` 的地方使用了赋值运算符 `=` 。（这样的程序可能是良构的，但是却没有正确反映出程序员的意图）。

实现语法分析器中的错误处理程序应考虑到如下需求：

- 清晰精确地报告出现的错误。
- 能很快地从各个错误中恢复，以继续检测后面的错误。
- 尽可能少地增加处理正确程序时的开销。

### 4.1.3 错误恢复策略

- 恐慌模式的恢复
  - 语法分析器一旦发现错误就不断丢弃输入中的符号，一次丢弃一个符号，直到找到 **同步词法单元** (synchronizing token) 集合中的某个元素为止。
  - 同步词法单元通常是界限符，比如 `;` 或者 `}` ,它们在源程序中的作用是清晰、无二义的。
  - 编译器的设计者必须为源语言选择适当的同步词法单元。
  - 恐慌模式的错误纠正方法常常会跳过大量输入，不检查被跳过部分的其他错误。
  - 实现简单，且能够保证不会进入无限循环。
- 短语层次的恢复
  - 当发现一个错误时，语法分析器可以在余下的输入上进行局部性纠正。即其可能将余下输入的某个前缀替换为另一个串，使语法分析器可以继续分析。
  - 常用的局部纠正方法包括将一个逗号替换为分号、删除一个多余的分号或者插入一个遗漏的分号。
  - 如何选择局部纠正方法是由编译器设计者决定的。
  - 必须小心选择替换方法，以避免进入无限循环。
  - 短语层次替换方法已经在多个错误修复型编译器中使用，它可以纠正任何输入串。它主要的不足在于它难以处理实际错误发生在被检测位置之前的情况。
- 错误产生式
  - 通过预测可能遇到的常见错误，我们可以在当前语言的文法中加入特殊的产生式。
  - 产生式能够产生含有错误的构造，从而基于增加了错误产生式的文法构造得到一个语法分析器。
  - 如果语法分析过程中使用了某个错误产生式，语法分析器就检测到了一个预期的错误。语法分析器能够据此生成适当的错误诊断信息，指出在输入中识别出的错误构造。
- 全局纠正
  - 在理想情况下，我们希望编译器在处理一个错误输入串时通过最少的改动将其转化为语法正确的串。
  - 有些算法可以选择一个最小的改动序列，得到开销最低的全局性纠正方法。
  - 给定一个不正确的输入 $x$ 和文法 $G$ ，这些算法将找出一个相关串 $y$ 的语法分析树，使得将 $x$ 转换为 $y$ 所需要的插入、删除和改变的词法单元的数量最少。
  - 由于从时间和空间的角度上，实现这些方法一般来说开销太大，因此这些技术当前仅具有理论价值。

请注意，一个最接近正确的程序可能并不是程序员想要的程序。不管怎样，最低开销纠正的概念仍然提供了一个可用于评价错误恢复技术的指标，并已经用于为短语层次的恢复寻找最佳替换串。

## 4.2 自顶向下分析

### 4.2.1 自顶向下分析概念

**自顶向下的分析** (Top-Down Parsing) ：

- 从分析树的顶部（根节点）向底部（叶节点）方向构造分析树。
- 可以看成是从文法开始符号 $S$ 推导出词串 $w$ 的过程。

> 文法：
>
> $$
> \begin{align*}
> & E \rightarrow E + E \\
> & E \rightarrow E * E \\
> & E \rightarrow ( E ) \\
> & E \rightarrow id    \\
> \end{align*}
> $$
>
> 输入：
>
> $$
> id + ( id + id )
> $$
>
> 分析树：
>
> ![自顶向下分析树](../pic/top-downTree.svg)
>
> 推导过程：
>
> $$
> \begin{align*}
> E & \Rightarrow E + E \\
>   & \Rightarrow E + ( E ) \\
>   & \Rightarrow E + ( E + E ) \\
>   & \Rightarrow E + ( id + E ) \\
>   & \Rightarrow E + ( id + id ) \\
>   & \Rightarrow id + ( id + id ) \\
> \end{align*}
> $$

### 4.2.2 自顶向下分析方法

在自顶向下的分析中，每次单步分析需考虑两个问题：

- 替换当前句型中的哪个 **非终结符** 。
- 用该非终结符的哪个 **候选式** 进行替换。

因此分析树存在两种推导方式：

- **最左推导**
  - 优先选择最左非终结符。
  - 同路径的归约方式为 **最右归约**。
  - 如果 $S {{\Rightarrow}^{*}}_{lm} \alpha$ ，则称 $\alpha$ 是当前文法的 **最左句型** (left-sentential form) 。
  - 在自顶向下的分析中，一般采用 **最左推导** 的方式。
- **最右推导**
  - 优先选择最右非终结符。
  - 同路径的归约方式为 **最左归约**。
  - 在自底向上的分析中，一般采用 **最左归约** 的方式，因此把 **最左归约** 称为 **规范归约**，**最右推导** 称为 **规范推导**。

最左推导与最右推导具有唯一性。

### 4.2.3 递归向下分析

**递归向下分析** (Recursive-Descent Parsing) 是自顶向下分析的通用形式。

- 由一组 **过程** 组成，每个过程对应一个 **非终结符**。
- 从文法开始符号 $S$ 对应的过程开始，递归调用文法中其它非终结符对应的过程。
- 如果 $S$ 对应的过程体恰好扫描了整个输入串，则成功完成语法分析。

由于对于同一个非终结符可能存在多个产生式，因此通用的递归下降分析技术可能需要 **回溯** (Backtracking)。  
回溯是重复扫描输入的过程，极影响分析效率。

#### 4.2.3.1 FIRST 和 FOLLOW

$FIRST(\alpha)$ ：  
可从 $\alpha$ 推导得到的串的 **首符号** 的集合。

- $\alpha$ 是任意的文法符号串。
- 允许 $\varepsilon$ 添加至 $FIRST(\alpha)$ 中。
- 分析方法：
  - 如果 $X$ 是一个终结符号，则 $FIRST(\alpha) = X$ 。
  - 如果 $X$ 是一个非终结符号，且 $X \rightarrow Y_1 Y_2 \dots Y_k$ 是一个产生式，若对于某个 $i \leqslant k$ ，$a$ 在 $FIRST(Y_i)$ 中且 $\varepsilon$ 在所有的 $FIRST(Y_1)、FIRST(Y_2)、\dots、FIRST(Y_{i-1})$ 中，则 $a$ 添加至 $FIRST(\alpha)$ 中。
  - je

$FOLLOW(A)$ ：  
可能在某些句型中紧跟在 $A$ 右边的终结符号的集合。

- 若 $A$ 是某些句型的最右符号，则 `$` 将添加至 $FOLLOW(A)$ 中。
- 分析方法：

#### 4.2.3.1 预测分析

预测分析 (Predictive Parsing) 是 **递归下降分析** 技术的一个特例。

通过在输入中向前看 **固定个数** （通常为 1 ）的符号来选择正确的产生式。

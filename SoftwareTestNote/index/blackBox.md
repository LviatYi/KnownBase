# 3. 黑盒测试

黑盒测试中，测试者在不考虑程序内部的实现的前提下，对程序接口进行测试。  

黑盒测试只检查程序功能是否能按照需求规格说明书的规定正确使用。  

## 3.1 边界值测试

### 3.1.1 边界条件

**边界条件** 在条件 $C$ 下，软件执行一种操作，对任意小的值 $\sigma$ ，条件 $C+\sigma$ 或 $C-\sigma$ 会执行另外的操作，则 $C$ 是一个边界。  

一般地，边界值可从常识或规格说明书得到。  

#### 3.1.1.1 内部边界条件

在软件测试用例测试过程中，某些边界条件不需要呈现给用户，或者说用户很难注意到，但属于检验范畴内的边界条件，称为 **内部边界条件** 或 **次边界条件** 。  

内部边界条件主要分为以下几种：  

* **数值边界值** 例如 int 类型，在 $-2^{31}+1 \sim 2^{31}$ 之间。  
* **字符边界值** 例如 Acsii 码值。  
* **其他边界条件**  
  * 空值后确认  
  * 默认值  
  * 空白值（多个空格）  
  * 0 值  

#### 3.1.1.2 边界值取值

一般地，确定边界值有以下几条原则。  

1. 若有范围，则取这个范围的边界的值，以及各个超越这个范围边界的值。  
2. 若输入条件规定了值的个数，则取最大个数，最小个数，最大个数 - 1 ，最小个数 + 1 。  
3. 若程序的规格说明给出的输入域或输出域是有序集合，则取集合的第一个元素和最后一个元素。  
4. 若程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界值。  
5. 分析规格说明，找出其他可能的边界条件。  

### 3.1.2 边界值分析

取输入变量的最小值，略大于最小值，正常值，略小于最大值，最大值。  
通常它们表示为 ```min``` , ```min+``` , ```nom``` , ```max-``` , ```max``` 来表示。  

若程序有多个输入变量，需要考虑如何组合各变量的取值。  

* **单缺陷假设** 假设失效极少由于多个缺陷同时发生引起的。  
* **多缺陷假设** 假设失效是由多个缺陷同时发生引起的。  

一般在边界值分析中，使用单缺陷假设。  

> 若 $a \in [0 , 10],b \in [10 , 20]$ 则取  
> $\{<0,15> , <1,15> , <9,15> , <10,15> , <5,10> , <5,11> , <5,19> , <5,20> , <5,15>\}$

### 3.1.3 健壮性边界测试

健壮性（鲁棒性）是指在异常情况下，软件还能正常运行的能力。健壮性可衡量软件对于规范要求以外的输入情况的处理能力。  

取输入变量的最小值，略大于最小值，正常值，略小于最大值，最大值。  
通常它们表示为 ```min-``` , ```min``` , ```min+``` , ```nom``` , ```max-``` , ```max``` , ```max+``` 来表示。  

> 若 $a \in [0 , 10],b \in [10 , 20]$ 则取  
> $\{<-1,15> , <0,15> , <1,15> , <9,15> , <10,15> , <11,15> , <5,9> , <5,10> , <5,11> , <5,19> , <5,20> , <5,21> , <5,15>\}$

### 3.1.4 最坏情况测试

取输入变量的最小值，略大于最小值，正常值，略小于最大值，最大值。  
通常它们表示为 ```min-``` , ```min``` , ```min+``` , ```nom``` , ```max-``` , ```max``` , ```max+``` 来表示。  

最坏情况测试采用 **多缺陷假设** ，即它关心多个变量取极值时出现的情况。因此对于 $n$ 个变量的函数，会产生 $5^n$ 个测试用例。  

> 若共两个输入变量，则最坏情况测试产生 25 个测试用例。  

## 3.2 等价类测试

### 3.2.1 等价类

#### 3.2.1.1 等价类的划分

等价类划分是将输入定义域进行划分，并且划分的各个子集是由等价关系决定的。这里的等价关系是指：在子集中，各个输入数据对于揭露程序程序中的错误都是等效的。且做如下合理假设：测试某等价类的代表值就等于对这个类中其它值的测试。  

等价类划分有两种不同情况：  

* 有效等价类  
* 无效等价类

#### 3.2.1.2 划分方法

* **按照区间划分** 在输入条件规定了取值范围或值的个数的情况下，可以确立一个有效等价类和两个无效等价类。  
* **按照数值划分** 规定了一组 n 个输入数据，则可以确定 n 个有效等价类和一个无效等价类。  
* **按照数值集合划分** 规定了「必须如何」的规则，则可以确定一个有效等价类和一个无效等价类。例如「以字母开头」和「以非字母开头」。  
* **布尔划分** 规定了输入条件是一个布尔值，则可以确定一个有效等价类和一个无效等价类。  
* **进一步细分等价类** 在确定已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步划分为更小的等价类。  
* **其他划分** 默认值，空白值，NULL， 0 值等。  

#### 3.2.1.3 等价类的特点

* **完备性** 划分出的各个等价类（子集）的并集是输入/输出的全集，即程序的定义域/值域。  
* **无冗余性** 各个等价类是互不相交的一组子集。  
* **等价性** 划分的各个子集是有等价关系决定的。因此只要选择等价类中具有代表性的一组数据即可达到测试目的。  

### 3.2.2 等价类测试类型

假设一个具有两个变量 $x_1$ 和 $x_2$ 的函数 $F$ 为例，  
输入变量 $x_1$ 和 $x_2$ 的边界以及边界内的区间为：  

$a \leqslant x_1 \leqslant d$ ，区间为 $[a,b) , [b,c) , [c,d]$  
$e \leqslant x_2 \leqslant g$ , 区间为 $[e,f) , [f,g]$  

![两个变量的边界及边界内区间的划分](..\Pic\两个变量的边界及边界内区间的划分.png)  

#### 3.2.2.1 弱一般等价类测试

弱一般等价类采用单缺陷假设。  

![弱一般等价类测试](..\Pic\弱一般等价类测试.png)  

#### 3.2.2.2 强一般等价类测试

强一般等价类采用多缺陷假设。  

![强一般等价类测试](..\Pic\强一般等价类测试.png)  

#### 3.2.2.3 弱健壮等价类测试

弱健壮等价类测试基于单缺陷假设，但考虑了无效值。  

![弱健壮等价类测试](..\Pic\弱健壮等价类测试.png)  

#### 3.2.2.4 强健壮等价类测试

强健壮等价类测试基于单缺陷假设，但考虑了无效值。  

![强健壮等价类测试](..\Pic\强健壮等价类测试.png)  

### 3.2.3 用等价类设计测试用例

1. 划分等价类
  根据输入或输出条件划分等价类。  
2. 建立等价类表

  | 输入 | 有效等价类 | 无效等价类|
  |-|----|-------|
  | | | |

3. 选择测试用例

* 为每一个等价类规定一个唯一的编号。  
* 测试一个设计用例，使其尽可能多地覆盖尚未覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止。  
* 设计一个测试用例，使其仅覆盖一个尚未被覆盖的有效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。  

### 3.2.4 等价类测试指导方针

* 等价类测试的弱形式不如对应的强形式的测试全面。  
* 如果实现预言是强类型，则没有必要使用健壮形式的测试。  
* 如果错误条件非常重要，则进行健壮形式的测试是合适的。  
* 如果输入数据以离散值区间和集合定义，则等价类测试是合适的。当然也适用于如果变量值越界系统就会出现故障的系统。  
* 通过结合边界值测试，等价类测试可以得到加强。  
* 如果程序函数很复杂，则等价类测试是被指示的。在这种情况下，函数的复杂性可以帮助标识有用的等价类。  
* 强等价类测试假设变量是独立的，相应的测试用例相乘会引起冗余问题。如果存在依赖关系，则常常会生成错误测试用例。  
* 在发现合适的等价关系之间，可能需要进行多次尝试。  

## 3.3 判定表测试

在一些数据处理问题中，某些操作是否实施取决于多个逻辑条件的取值。在这些逻辑条件取值的组合所构成的多种情况下，分别执行不同的操作。  

处理这类问题的一个非常有用的分析和表达工具是 **决策表** (Decision Table) ，即 **判定表** 。  

在所有功能性测试方法中，基于判定表的测试方法是最严格的。  

### 3.3.1 判定表的组成

桩 | 规则
:--:|:---:
条件桩 | 条件项
动作桩 | 动作项

**条件桩** (Condition Stub) 列出了问题的所有条件。通常认为列出的条件的次序无关紧要。  
**动作桩** (Action Stub) 列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。  
**条件项** (Condition Entry) 列出针对它所列条件的取值。  
**动作项** (Action Entry) 列出在条件项的各种取值情况下应采取的动作。  

桩 | 规则 1 | 规则 2 | 规则 3 | 规则 4 | 规则 5 | 规则 6 | 规则 7
--|------|------|------|------|------|------|------
条件 1 | T | T | T | T | F | F | F
条件 2 | T | T | F | F | T | F | F
条件 3 | T | F | T | F | -- | T | F
动作 1 | $\checkmark$ || $\checkmark$ | $\checkmark$ |||
动作 2 | $\checkmark$ |||| $\checkmark$ | $\checkmark$ |
动作 3 || $\checkmark$ || $\checkmark$ || $\checkmark$ ||
动作 4 ||||||| $\checkmark$ |

「--」表无关条件项。  

规则 1 | 规则 2
-----|-----
T | T
F | F
T | F
$\checkmark$ | $\checkmark$

可简化为：  

规则 1 |
-----|
T |
F |
-- |
$\checkmark$ |

### 3.3.2 基于判定表的测试

为了使用判定表标识测试用例，一般把条件解释为程序的输入，吧动作解释为输出。  

设计判定表的步骤如下：  

1. 确定规则个数。  
  假设有 $n$ 个条件，每个条件有两个取值（「真」和「假」），则会产生 $2^n$ 条规则。如果每个条件的取值有多个值，则规则数等于各条件取值个数的积。  
2. 列出所有条件桩和动作桩。  
3. 填入条件项。  
4. 填入动作项。  
5. 简化判定表，合并相似规则。  

### 3.3.3 判定表测试指导方针

适合使用判定表设计测试用例的条件：  

* 规格说明以判定表形式给出，或很容易转换成判定表。  
* 条件的排列顺序不会也不影响执行哪些操作。  
* 规则的排列顺序不会也不影响执行哪些操作。  
* 每当规则某一的条件已经满足，并确定要执行的操作后，不必检验别的规则。  
* 如果某一规则得到满足要执行多个操作，这些操作的执行顺序无关紧要。  

## 3.4 因果图

输入为原因，输出和转换为结果，反映这种关系的图即因果图。  

因果图能够很清晰地反映输入条件与输出结果的逻辑关系。  
因果图最终生成 **判定表** 。  

### 3.4.1 因果图的关系

* **恒等** 若 $c_1$ 为 1 ，则 $e_1$ 为 1 ；若 $c_1$ 为 0 ，则 $e_1$ 为 0 。
![恒等关系](../pic/恒等关系.svg)
* **非** 若 $c_1$ 为 1 ，则 $e_1$ 为 0 ；若 $c_1$ 为 0 ，则 $e_1$ 为 1 。
![非关系](../pic/非关系.svg)
* **或** 若 $c_1$ 或 $c_2$ 为 1 ，则 $e_1$ 为 1 ；若 $c_1$ 与 $c_2$ 为 0 ，则 $e_1$ 为 0 。
![或关系](../pic/或关系.svg)
* **与** 若 $c_1$ 与 $c_2$ 为 1 ，则 $e_i$ 为 1 ；否则 $e_i$ 为 0 。  
![与关系](../pic/与关系.svg)

其中或关系和与关系都可以有多个条件。  

### 3.4.2 因果图的约束条件

* **E** 异 表示 $c_1$ 、 $c_2$ 至多有一个为 1 。  
![异](../pic/异.svg)
* **I** 或 表示 $c_1$ 、 $c_2$ 至少有一个为 1 。  
![或](../pic/或.svg)
* **O** 唯一 表示 $c_1$ 、 $c_2$ 有且只有一个为 1 。  
![唯一](../pic/唯一.svg)
* **R** 要求 表示 $c_1$ 为 1 时， $c_2$ 必须为 1 。  
![要求](../pic/要求.svg)
* **M** 强制 若结果 $e_1$ 为 1 ，则 $e_2$ 为 0 。  
![强制](../pic/强制.svg)

## 3.5 其他黑盒测试方法

### 3.5.1 正交实验

正交实验测试策略提供一种能对所有变量组合进行典型覆盖（均匀分布）的方法。  

#### 3.5.1.1 正交表概念

正交表是运用组合数学理论在正交拉丁名的基础上构造的一种规格化的表格，其符号为 $L_{n}(j^{i})$ 。  
其中：  
$L$ 正交表符号。  
$n$ 正交表次数 (Runs) ，即正交表行数。  
$j$ 正交表水平数 (Levels) ，任何单个因素能够取得的值的最大个数。  
$i$ 正交表因素数 (Factors) ，即正交表列数。它直接对应到用这种技术设计测试用例时的变量的最大个数。  

各列水平数相同的正交表称为单一水平正交表。  
否则称为混合水平正交表。  


# 4. 白盒测试

**静态白盒测试** 是在不执行程序的条件下有条理地仔细审查软件设计、体系结构和代码，从而找出软件缺陷的过程，即 **结构化分析** 。  
**动态白盒测试** 是指利用查看代码功能和实现方式得到的信息来确定哪些需要测试，哪些不需要测试，如何开展测试，即 **结构化测试** 。测试者可以查看并使用代码的内部结构来设计和执行用例。  

## 4.1 程序结构分析

### 4.1.1 基本概念

#### 有向图

有向图 $D(V,E)$ 由有限的节点的集合 $V=\{n_1,n_2,\dots,n_m\}$ 和边的集合 $E=\{e_1,e_2,\dots,e_p\}$ 组成。  
其中每条边 $e_k=<n_i,n_j>$ 是节点 $n_i,n_j \in V$ 的一个有序对偶，$n_j$ 是 $n_i$ 的后继节点，$n_i$ 是 $n_j$ 的前驱节点。在有向图中边用箭头线表示， $e_k=(T(e_k),H(e_k))\in E$ ，$T(e_k)$ 是尾，$H(e_k)$ 是头。  

![有向图](../pic/有向图.svg)
在有向图中，节点的入度是将该节点作为终止节点的不同边的条数（指向该节点的边数），记作 indegree(n) ，节点的出度是将该节点作为开始节点的不同边的条数（出发于该节点的边数），记作 outdegree(n) 。  

#### 路径

在有向图中，路径是一系列边，使得对于该系列中的所有相邻边对偶 $e_i,e_j$ 来说，第一条边的头是第二条边的尾（即头尾相连的一系列边）。若有 $P=e_1e_2\cdots e_q$ ，且满足 $T(e_{i+1})=H(e_i)$，则 $P$ 称为路径， $q$ 称为路径长度。  

#### 半路径

在有向图中，半路径是一系列边，使得对于该序列中至少有一个相邻边对偶 $e_i,e_j$ 来说，第一条边的尾是第二条边的尾，或者第一条边的头是第二条边的头。  

#### 可达

如果 $e_i$ 到 $e_j$ 存在一条路径，则 $e_i$ 到 $e_j$ 是可达的。  

#### 简单路径

如果路径上所有的节点都是不同的，则称为简单路径。  

#### 回路

路径 $P=e_1e_2\cdots e_q$ 满足 $H(e_{q})=T(e_1)$ 则为回路。除了第一个节点和最后一个节点外，其他节点都不同的回路称为简单回路。  

#### 连接

A 连接 B ，指路径 A 与路径 B 首尾相连时可以形成新的路径，记为 A*B 。  
当一条路径是回路时，它可以和自己连接，记为 $A^1=A，A^{k+1}=A*A^k$ 。  

#### 覆盖

路径 A 覆盖路径 B ，指路径 B 中所含的有向边均在路径 A 中出现，则成路径 A 覆盖路径 B 。  

### 4.1.2 控制流图

控制流图是简化的程序流程图。  
控制流图采用仅有圆形结点和带箭头线条的有向图描述程序流程。  

有向图可以转换为矩阵，因此控制流图也可以转换为控制流图矩阵。  

![控制流图](../pic/控制流图.svg)

## 4.2 逻辑覆盖

逻辑覆盖测试 (Logic Coverage Testing) 是根据被测试程序的逻辑结构设计测试用例。  
逻辑覆盖测试考察的重点是流程图中的判定框，即控制流图中出度大于 1 的节点。  

按照对被测程序所做测试的有效程度，逻辑覆盖测试可由弱到强区分为六种覆盖：  

覆盖类型 | 覆盖方式
:-------: | -------
语句覆盖 | 每条语句至少执行一次
判定覆盖 | 每个判定的每条分支至少执行一次
条件覆盖 | 每条判定中的每个条件，分别按「真」、「假」至少各执行一次
判定 - 条件覆盖 | 同时满足判定覆盖和条件覆盖的要求
条件组合覆盖 | 求出判定中所有条件的各种可能组合值，每个可能的条件组合至少执行一次
路径覆盖 | 每条可能的路径至少执行一次

给出如下的程序流程图：  

```Mermaid
flowchart TB

start(start)--"A"--->n1
n1--"C True"-->n2
n1--"B False"-->n3
n2-->n3

n3--"E True"-->n4
n3--"D False"-->n5
n4-->n5
n5-->End(end)

n1{"(a>1)and(b=0)"}
n2["c=c/a"]
n3{"(a=5)or(c>1)"}
n4["c=c+1"]
n5["c=a+b+c"]

```

### 4.2.1 语句覆盖

语句覆盖 (Statement Coverage) 指设计用例会使得程序中每条可执行语至少执行一次。  

对于实例的程序流程图，可采用：  

$$a=5,b=0,c=6$$

执行路径 ACE ，则实现了语句覆盖。  

若某个判定条件错误而使得其判断永真时，语句覆盖将放过问题。  
实际上，语句覆盖是 **最弱的** 覆盖。  

### 4.2.2 判定覆盖

判定覆盖 (Decision Coverage) 又称为分支覆盖，指设计用例会使得每个判断的真假分支都至少经历一次。  

对于实例的程序流程图，可采用：  

$$a=5,b=0,c=6$$
$$a=1,b=0,c=1$$

覆盖路径 ACE 和 ABD ，从而使两个判断的 4 个分支都得到覆盖。  

然而与语句覆盖一样，判定覆盖是对 ```||``` 与 ```&&``` 不敏感的。可能会因为短路效应而不能完整判断。  

条件覆盖可以 **优化** 这个问题。  

### 4.2.3 条件覆盖

条件覆盖 (Condition Coverage) 将判断拆分为条件。  

对于上一个程序，拆分出如下条件：  

条件 | 真 | 假
---|---|--
 ```a>1``` | T1 | F1
 ```b=0``` | T2 | F2
 ```a=5``` | T3 | F3
 ```c>1``` | T4 | F4

设计条件覆盖测试用例时，应覆盖以上所有条件。  

测试数据 | 覆盖条件 | 执行路径
-----|:------:|:-----:
$a=5,b=2,c=1$ | T1 F2 T3 F4 | ABE
$a=1,b=0,c=2$ | F1 T2 F3 T4 | ABE

刚刚提到，条件覆盖仅是 **优化** 了短路性问题，实际上，条件覆盖不一定能完美地测试所有条件。  

条件覆盖不一定能够覆盖所有分支。  
因此可以将条件覆盖与判定覆盖相结合。  

### 4.2.4 判定 - 条件覆盖

判定 - 条件覆盖 (Decision-Condition Coverage) 即同时满足判定覆盖与条件覆盖的测试用例设计方法。  

测试数据 | 覆盖条件 | 执行路径
-----|:------:|:-----:
$a=5,b=0,c=6$ | T1 T2 T3 T4 | ACE
$a=1,b=2,c=1$ | F1 F2 F3 F4 | ABD

### 4.2.5 条件组合覆盖

条件组合覆盖 (Condition Combination Coverage) 指设计用例使得所有可能的按照判断语句组合的条件取值至少执行一次。  

条件组合覆盖可以完美解决短路性问题。  

条件组合：  
条件取值 | 覆盖条件 | 判定取值
:-----:|:------:|:-----:
$a>1,b=0$ | T1 T2 | 第一个判定：取真
$a>1,b \ne 0$ | T1 F2 | 第一个判定：取假
$a \leqslant 1,b=0$ | F1 T2 | 第一个判定：取假
$a \leqslant 1,b \ne 0$ | F1 F2 | 第一个判定：取假
$a=5,c > 1$ | T3 T4 | 第二个判定：取真
$a=5,c \leqslant 1$ | T3 F4 | 第二个判定：取真
$a \ne 5,c > 1$ | F3 T4 | 第二个判定：取真
$a \ne 5,c \leqslant 1$ | F3 F4 | 第二个判定：取假

测试用例：  
测试用例 | 覆盖条件 | 覆盖分支 | 执行路径
:-----:|:------:|:------:|:-----:
$a=5,b=0,c=6$ | T1 T2 T3 T4 | C E | ACE
$a=5,b=2,c=1$ | T1 T2 T3 T4 | B E | ABE
$a=1,b=0,c=3$ | T1 T2 T3 T4 | B E | ABE
$a=1,b=3,c=0$ | T1 T2 T3 T4 | C D | ABD

如上的测试用例，包含了所有条件的不同取值和分支。但是仍不完美，因为没有考虑到所有路径。  

因此有路径覆盖。  

### 4.2.6 路径覆盖

路径覆盖 (Path Coverage) 指设计用例使得所有路径都至少执行一次。  

测试用例：  
测试用例 | 执行路径
:-----:|:-----:
$a=5,b=0,c=6$ | ACE
$a=1,b=0,c=1$ | ABD
$a=5,b=2,c=1$ | ABE
$a=3,b=0,c=1$ | ACD

可以考虑将路径覆盖与条件组合覆盖，达成 **最强** 覆盖。  

真的吗？示例程序非常简单，若稍复杂，路径数则呈指数级增长。且若考虑循环，则路径无穷。因此，路径循环在实际应用中，很难完整地实现。  

### 4.2.7 最强覆盖？

实际上并不存在最强覆盖。因为还有更多值得考虑的地方。比如：边界值。  

也许可以用测试用例 $a=5,b=2$ 验证 `a<5||b=2` 这样的判断语句，但若误写作 `a<=5||b=2` ，则此测试用例便爱莫能助了。  

软件测试很难消灭所有 bug ，更不存在什么 **最强覆盖** 。在实际应用中，应选择最适合的方案进行测试。  

## 4.3 路径测试

### 4.3.1 基路径测试

#### 4.3.1.1 程序环路复杂性

程序的环路复杂性即 McCabe 复杂性度量，反映程序的环路数量。  
设 $E$ 为控制流图边数，$N$ 为节点数，则有：  

$$环路复杂性 \ V(G)=E-N+2$$

设 $P$ 为控制流图判定节点数，则有：  

$$环路复杂性 \ V(G)=P+1$$

上面的示例程序中，环路复杂性为 3 。  

#### 4.3.1.2 独立路径

独立路径是指包括一组以前没有处理的语句或条件的一条路径。控制流图中所有独立路径的集合就构成了基本路径集。  

> ![控制流图](../pic/控制流图.svg)
>  
> 在这张图中，一组独立的路径是：  
> path1 1-2-7
> path2 1-2-3-4-6-2-7
> path3 1-2-3-5-6-2-7
>  
> path1 path2 path3 共同组成基本路径集。  

选择独立路径的原则如下：  

1. 选择具有功能含义的路径。  
2. 尽量用短路径代替长路径。  
3. 从上一条测试路径到下一条测试路径，应尽量减少变动的部分。  
4. 由简入繁，如果可能，应先考虑不含循环的测试路径，然后补充对循环的测试。  
5. 除非不得已，不要选取没有明显功能含义的复杂路径。  

#### 4.3.1.3 基路径测试方法

1. 根据详细设计或者程序源代码，绘制出程序的程序流程图。  
2. 根据程序流程图，绘制出程序的控制流图。  
3. 计算程序环路复杂度。  
4. 找出独立路径。通过程序的控制流图导出基本路径集，列出程序的独立路径。  
5. 设计测试用例。根据程序结构和程序环路复杂性设计用例输入数据和预期结果，确保基本路径集中的每一条路径的执行。  

### 4.3.3 循环测试

#### 4.3.3.1 简单循环测试

```Mermaid
flowchart TD
start(...)-->dosth["..."]-->judge{"..."}
judge-->start
judge-->End(...)
```

循环测试的最基本形式即简单循环。  

对于简单循环，可设置一下五种测试集：  

1. 零次循环：直接从循环入口跳过整个循环。  
2. 一次循环  
3. 两次通过循环  
4. m 次通过循环，m < 最大循环次数，一般取最小循环次数与最大循环次数的中间值。  
5. n-1 ：其中 n 为最大循环次数。  

#### 4.3.3.2 嵌套循环测试

```Mermaid
flowchart TD
start(...)-->dosth["..."]-->judge{"..."}
judge-->start
judge-->judge2{"..."}
judge2-->start
judge2-->End(...)
```

对于嵌套循环，可按照如下方法进行测试：  

1. 从最内层循环开始（不含最内层循环），将所有其他层循环设置为最小值。  
2. 对最内层循环使用简单循环的全部测试。测试时保持所有外层循环的迭代参数（即循环变量）取最小值，并为超越边界值或非法制增加其他测试。  
3. 由内向外构造下一个循环的测试。测试时保持所有外层循环的循环变量取最小值，并使其他嵌套内层循环的循环变量取典型值。  
4. 反复进行，直到测试所有循环。  

#### 4.3.3.3 串接循环

```Mermaid
flowchart TD
start(...)-->dosth["..."]-->judge{"..."}
judge-->start
judge-->dosth2["..."]
dosth2-->judge2{"..."}
judge2-->judge
judge2-->End(...)
```

多个简单循环串接在一起即串接循环。  

当循环间无联系则应分别使用简单循环方法。否则使用嵌套循环方法。  

#### 4.3.3.4 非结构性循环

```Mermaid
flowchart TD
start(...)-->dosth["..."]-->dosth1["..."]-->judge{"..."}
judge-->start
judge-->dosth2["..."]
dosth2-->judge2{"..."}
judge2-->dosth1
judge2-->End(...)
```

使用 GOTO 语句，并导致程序到处乱跳的程序员应该杀了祭天。  

## 4.4 数据流测试

## 4.5 其他白盒测试方法

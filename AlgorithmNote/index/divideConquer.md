# 2. 分治法

## 2.1 概述

**分治法** (Divide and Conquer) 将一个复杂问题分解成若干个 **规模较小** ， **相互独立** ，**类型相同** 的子问题，然后将各子问题的解组合成原始问题的解。

- 规模较小：当规模小的时候将会容易得到求解答案。
- 相互独立：避免在递归的时候重复计算，提高效率。
- 类型相同：方便递归实现。

由于分治法的分治特性，因此其与递归常常伴随使用。  
每层递归中应用如下三个步骤：

- 分解 Divide
  - 将问题划分为一些子问题。
  - 子问题的形式与原问题一样，只是规模更小。
- 解决 Conquer
  - 递归地求解出子问题。
  - 如果子问题的规模足够小，则停止递归，直接求解。。
- 合并 Combine
  - 将子问题的解组合成原问题的解。

## 2.2 时间复杂度分析

分析分治算法可以得到如下递推关系式：

$T(n)=aT(n/b)+cn^{k}$

其表示规模为 $n$ 的问题被分成了 $a$ 个规模为 $n/b$ 的子问题， $cn^k$ 是进行问题分解及将各子问题的解合并成原始问题的解所需的工作量。

因此有：

$$
T(n)=
    \begin{cases}
        \Theta (n^{log_b{a}}),   & \text{如果 $a > b^{k}$}\\
        \Theta (n^{k}log{n}),   & \text{如果 $a = b^{k}$}\\
        \Theta (n^k),   & \text{如果 $a < b^{k}$}\\
    \end{cases}
$$

## 2.3 算法

### 2.3.1 最大子数组

> `FIND_MAX_CROSSING_SUBARRAY(A,low,mid,high)`

```pascal {.line-numbers}
left_sum = INT_MINIMUM
sum = 0
for i = mid downto low
```
